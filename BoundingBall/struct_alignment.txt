  studentのメンバ変数に割り当てられるアドレスが0x7ffee5f6d918から0x7ffee5f6d997です。
  合計128でsizeof(struct student)を利用して表示しました。
  idがint型で、サイズが4バイトで、割り当てられるアドレスが0x7ffeeebac918から0x7ffeeebac91bです。
  それと同じく、nameがchar型の配列で、ageがint型で、heightとweightがdouble型で、
  それぞれの100バイト、4バイト、8バイトのサイズの応じて、アドレスが割り当てられます。
  その中で、ageがアラインメントのため、8バイトのアドレスが割り当てられます。
  
  tagged_student1メンバ変数に割り当てられるアドレスが0x7ffeeebac890から0x7ffeeebac917です。
  スタックみたいで、studentの上のアドレスが割り当てられています。
  この構造体の中の変数それぞれの型に対して、アドレスが割り当てられています。
  そして、最後の変数の型がcharですから、0x7ffeeebac911からのアドレスがパディングです。
  8バイト境界へのアラインメントになります。

  tagged_student2メンバ変数に割り当てられるアドレスが0x7ffee1ec5810から0x7ffee1ec588fです。
  最初の変数がchar型のcharですけど、サイズが1バイトのがはずですが、4バイト境界へのアラインメントのため4バイトが割り当てられています。
  最後は合計128バイトです。
  
  インターネットで調べたところ、多くのCPUが『奇数番地から始まるデータより偶数番地から始まるデータの方が効率的に扱える』ようになっているためです。
  そのため、char型配列の要素が奇数個の場合、さらに1バイトの「何もない領域」を追加して割り当て、次にメモリ上に確保されるであろうデータが偶数番地から始まるよう調整するのです。
  これもそれに似ていて、なにもないアドレスが割り当てられます。

